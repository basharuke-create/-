<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Gemini Hyper Agent v3 â€” Fixed</title>

<style>
    :root { --bg:#1e1e1e; --text:#d4d4d4; --accent:#007acc; }
    body { background:var(--bg); color:var(--text); font-family:sans-serif; padding:20px; }
    .container { max-width:900px; margin:0 auto; }
    textarea,input { width:100%; background:#2d2d2d; color:#fff; border:1px solid #444; padding:10px; margin-bottom:10px; border-radius:4px; }
    button { background:var(--accent); color:white; border:none; padding:10px 20px; cursor:pointer; border-radius:4px; font-weight:bold; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    #output { background:#000; padding:15px; border-radius:5px; height:520px; overflow-y:auto; white-space:pre-wrap; font-family:monospace; line-height:1.5; border-left:4px solid var(--accent); }
    .plan { color:#ce9178; }
    .exec { color:#9cdcfe; }
    .critic { color:#b5cea8; }
    .score { color:#ffcc00; }
    .final { color:#00ff9c; font-weight:bold; }
</style>
</head>

<body>
<div class="container">
    <h2>ğŸš€ Gemini Hyper Agent v3 <small style="font-size:0.5em;opacity:0.6;">Self-Improving AI</small></h2>

    <input type="password" id="apiKey" placeholder="Gemini API Key">
    <textarea id="prompt" rows="3" placeholder="ã‚¿ã‚¹ã‚¯ã‚’å…¥åŠ›"></textarea>

    <button id="runBtn">ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆèµ·å‹•</button>
    <button id="stopBtn" style="background:#cc0000; display:none;">åœæ­¢</button>

    <div id="output"></div>
</div>

<script type="module">

class HyperAgent {
    constructor(apiKey) {
        this.apiKey = apiKey;

        // â˜… æœ€æ–°ãƒ¢ãƒ‡ãƒ«åï¼ˆå®‰å®šï¼‰
        this.model = "gemini-1.5-flash-001";

        this.controller = null;
        this.history = [];
        this.buffer = "";
    }

    async callLLM(prompt, onChunk) {
        this.controller = new AbortController();

        // â˜… 404 ä¿®æ­£æ¸ˆã¿ï¼šv1beta â†’ v1
        const url =
`https://generativelanguage.googleapis.com/v1/models/${this.model}:streamGenerateContent?alt=sse&key=${this.apiKey}`;

        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            signal: this.controller.signal,
            body: JSON.stringify({
                contents: this.history.concat([{ parts: [{ text: prompt }] }]),
                generationConfig: { temperature: 0.4, maxOutputTokens: 1500 }
            })
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let full = "";

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            this.buffer += chunk;

            const lines = this.buffer.split("\n");
            this.buffer = lines.pop();

            for (const line of lines) {
                if (!line.startsWith("data:")) continue;

                const jsonText = line.replace("data:", "").trim();
                if (!jsonText) continue;

                try {
                    const json = JSON.parse(jsonText);
                    const text = json.candidates?.[0]?.content?.parts?.[0]?.text || "";
                    full += text;
                    onChunk(text);
                } catch (e) {
                    this.buffer = jsonText + this.buffer;
                }
            }
        }
        return full;
    }

    async run(task, onUpdate) {
        let best = "";
        let bestScore = 0;
        let feedback = "åˆå›å®Ÿè¡Œã€‚æ”¹å–„ç‚¹ã‚’æŠ½å‡ºã—ã¦æ¬¡ã«åæ˜ ã—ã¦ãã ã•ã„ã€‚";

        for (let i = 1; i <= 4; i++) {
            onUpdate(`\n\n=== ITERATION ${i} ===\n`);

            onUpdate("[PLAN] ", "plan");
            const plan = await this.callLLM(
                `Task: ${task}\nFeedback: ${feedback}\næ”¹å–„ç‚¹ã‚’è¸ã¾ãˆã€æœ€é©ãªè¨ˆç”»ã‚’4ã‚¹ãƒ†ãƒƒãƒ—ã§å†æ§‹æˆã›ã‚ˆã€‚`,
                (t) => onUpdate(t, "plan")
            );

            onUpdate("\n[EXECUTE] ", "exec");
            const result = await this.callLLM(
                `Plan: ${plan}\nTask: ${task}\nè¨ˆç”»ã‚’å®Ÿè¡Œã—ã€æ•°å€¤ãƒ»æ ¹æ‹ ãƒ»ãƒªã‚¹ã‚¯ãƒ»å®Ÿè¡Œæ‰‹é †ã‚’å«ã‚ã¦å…·ä½“åŒ–ã›ã‚ˆã€‚`,
                (t) => onUpdate(t, "exec")
            );

            onUpdate("\n[CRITIC] ", "critic");
            const critique = await this.callLLM(
                `Result: ${result}\nè«–ç†æ€§ãƒ»å…·ä½“æ€§ãƒ»å®Ÿè¡Œå¯èƒ½æ€§ã®3è»¸ã§100ç‚¹æº€ç‚¹ã§æ¡ç‚¹ã—ã€å½¢å¼ã¯ä»¥ä¸‹ã«å¾“ã†:\nSCORE: [æ•°å€¤]\nREASON: [ç†ç”±]`,
                (t) => onUpdate(t, "critic")
            );

            const score = parseInt(critique.match(/SCORE:\s*(\d+)/)?.[1] || "0");
            onUpdate(`\n[SCORE] ${score}\n`, "score");

            if (score > bestScore) {
                bestScore = score;
                best = result;
            }

            if (score >= 90) {
                onUpdate("\nğŸ‰ é«˜ã‚¹ã‚³ã‚¢é”æˆã€‚æœ€é©è§£ã‚’ç¢ºå®šã—ã¾ã™ã€‚\n", "final");
                break;
            }

            feedback = critique;
            this.history.push({ role: "user", parts: [{ text: result }] });
            this.history.push({ role: "model", parts: [{ text: "æ”¹å–„ç‚¹ã‚’ç†è§£ã€‚æ¬¡ã®åå¾©ã«åæ˜ ã—ã¾ã™ã€‚" }] });
        }

        onUpdate(`\n\nğŸ† FINAL RESULT (Score: ${bestScore})\n${best}\n`, "final");
    }

    stop() {
        if (this.controller) this.controller.abort();
    }
}

const runBtn = document.getElementById("runBtn");
const stopBtn = document.getElementById("stopBtn");
const outputEl = document.getElementById("output");
let agent = null;

function print(text, type) {
    const span = document.createElement("span");
    if (type) span.className = type;
    span.textContent = text;
    outputEl.appendChild(span);
    outputEl.scrollTop = outputEl.scrollHeight;
}

runBtn.addEventListener("click", async () => {
    const key = document.getElementById("apiKey").value;
    const task = document.getElementById("prompt").value;
    if (!key || !task) return alert("APIã‚­ãƒ¼ã¨ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ã§ã™");

    outputEl.textContent = "";
    runBtn.disabled = true;
    stopBtn.style.display = "inline";

    agent = new HyperAgent(key);

    try {
        await agent.run(task, print);
    } catch (e) {
        print(`\n[ERROR] ${e.message}`);
    } finally {
        runBtn.disabled = false;
        stopBtn.style.display = "none";
    }
});

stopBtn.addEventListener("click", () => agent?.stop());

</script>
</body>
</html>
