<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Hyper Agent v4</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --accent: #007acc; --border: #333; }
        body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; line-height: 1.6; }
        .container { max-width: 1000px; margin: 0 auto; }
        header { border-bottom: 2px solid var(--accent); margin-bottom: 20px; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: flex-end; }
        h1 { margin: 0; font-size: 1.5rem; color: var(--accent); }
        .config-panel { background: var(--panel); padding: 15px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 20px; }
        input, textarea { width: 100%; background: #2d2d2d; color: #fff; border: 1px solid var(--border); padding: 12px; margin-bottom: 10px; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
        .controls { display: flex; gap: 10px; }
        button { flex: 1; padding: 12px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; transition: 0.2s; color: white; }
        #runBtn { background: var(--accent); }
        #runBtn:hover { background: #005f99; }
        #stopBtn { background: #cc0000; display: none; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        #output { background: #000; padding: 20px; border-radius: 8px; height: 600px; overflow-y: auto; white-space: pre-wrap; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; border: 1px solid var(--border); }
        /* Syntax highlighting inside output */
        .status { color: #888; font-style: italic; }
        .plan { color: #ce9178; font-weight: bold; }
        .exec { color: #9cdcfe; }
        .critic { color: #b5cea8; }
        .score { color: #ffd700; font-size: 1.1em; border-bottom: 1px solid #ffd700; }
        .final { color: #4fc1ff; font-weight: bold; border: 1px solid #4fc1ff; padding: 10px; display: block; margin-top: 10px; }
        .error { color: #f44336; font-weight: bold; background: rgba(244, 67, 54, 0.1); padding: 5px; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>ğŸš€ Gemini Hyper Agent v4</h1>
        <span style="font-size: 12px; opacity: 0.6;">Maximum Reasoning Mode</span>
    </header>

    <div class="config-panel">
        <input type="password" id="apiKey" placeholder="Gemini API Key (Google AI Studio)">
        <textarea id="prompt" rows="3" placeholder="ã‚¿ã‚¹ã‚¯ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼š2026å¹´ã®å›½å†…SaaSå¸‚å ´ã®å‹ã¡ç­‹ã‚’åˆ†æã›ã‚ˆï¼‰"></textarea>
        <div class="controls">
            <button id="runBtn">åˆ†æé–‹å§‹ (Self-Refine)</button>
            <button id="stopBtn">ç·Šæ€¥åœæ­¢</button>
        </div>
    </div>

    <div id="output"></div>
</div>

<script type="module">

class AgentEngine {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.model = "gemini-1.5-flash"; // é€Ÿåº¦é‡è¦–ã€‚é«˜åº¦ãªåˆ†æã«ã¯ gemini-1.5-pro ã«å¤‰æ›´å¯
        this.controller = null;
    }

    async streamCall(prompt, history, onChunk) {
        this.controller = new AbortController();
        
        // â˜…ä¿®æ­£ç‚¹: v1betaã‚’ä½¿ç”¨ã—ã€SSEãƒ•ãƒ©ã‚°ã‚’èª¿æ•´
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:streamGenerateContent?key=${this.apiKey}`;

        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            signal: this.controller.signal,
            body: JSON.stringify({
                contents: history.concat([{ parts: [{ text: prompt }] }]),
                generationConfig: { 
                    temperature: 0.3, // æ¨è«–ã®å®‰å®šæ€§ã‚’å„ªå…ˆ
                    maxOutputTokens: 2048 
                }
            })
        });

        if (!response.ok) {
            const err = await response.json().catch(() => ({}));
            throw new Error(`[${response.status}] ${err.error?.message || 'APIé€šä¿¡ã‚¨ãƒ©ãƒ¼'}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullContent = "";

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            
            // Geminiã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã¯ç‰¹æ®ŠãªJSONã®é€£çµå½¢å¼ã§ãã‚‹ãŸã‚ã€æ­£è¦è¡¨ç¾ã§ãƒ‘ãƒ¼ãƒ„ã‚’æŠ½å‡º
            const textParts = chunk.match(/"text":\s*"(.*?)(?<!\\)"/g);
            if (textParts) {
                for (let part of textParts) {
                    let cleanText = part.replace(/"text":\s*"/, "").slice(0, -1);
                    // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ–‡å­—ã®å‡¦ç† (\n ç­‰)
                    cleanText = cleanText.replace(/\\n/g, "\n").replace(/\\"/g, '"');
                    fullContent += cleanText;
                    onChunk(cleanText);
                }
            }
        }
        return fullContent;
    }
}

class Orchestrator {
    constructor(apiKey, outputEl) {
        this.engine = new AgentEngine(apiKey);
        this.outputEl = outputEl;
        this.history = [];
    }

    print(text, type = "") {
        const span = document.createElement("span");
        if (type) span.className = type;
        span.textContent = text;
        this.outputEl.appendChild(span);
        this.outputEl.scrollTop = this.outputEl.scrollHeight;
    }

    async start(task) {
        let currentFeedback = "åˆå›å®Ÿè¡Œã€‚æœ€é«˜ç²¾åº¦ã®åˆ†æã‚’è¡Œãˆã€‚";
        let bestResult = "";
        let bestScore = 0;

        for (let i = 1; i <= 3; i++) {
            this.print(`\n\n--- ITERATION ${i} (Reasoning Depth: ${i * 33}%) ---\n`, "status");

            // 1. PLAN (4è¦–ç‚¹å¼·åˆ¶)
            this.print("\n[PLANNING]\n", "plan");
            const planPrompt = `Task: ${task}\nFeedback: ${currentFeedback}\nä¸Šè¨˜ã‚’è¸ã¾ãˆã€æˆ¦ç•¥ãƒ»è²¡å‹™ãƒ»ãƒªã‚¹ã‚¯ãƒ»å¿ƒç†ã®4è¦–ç‚¹ã‚’å«ã‚€å®Ÿè¡Œè¨ˆç”»ã‚’4ã‚¹ãƒ†ãƒƒãƒ—ã§ä½œæˆã›ã‚ˆã€‚`;
            const plan = await this.engine.streamCall(planPrompt, this.history, (t) => this.print(t, "plan"));

            // 2. EXECUTE (æ§‹é€ åŒ–ãƒ»æ•°å€¤åŒ–å¼·åˆ¶)
            this.print("\n\n[EXECUTING]\n", "exec");
            const execPrompt = `Plan: ${plan}\nTask: ${task}\nè¨ˆç”»ã‚’å®Ÿè¡Œã›ã‚ˆã€‚å›ç­”ã¯å¿…ãšï¼šãƒ»æ§‹é€ åŒ–ãƒ»æ•°å€¤åŒ–ãƒ»æˆåŠŸç¢ºç‡ã¨ãƒªã‚¹ã‚¯è©•ä¾¡ãƒ»åå¯¾æ„è¦‹ ã‚’å«ã‚€ã“ã¨ã€‚æ›–æ˜§ãªè¡¨ç¾ã¯ç¦æ­¢ã€‚`;
            const result = await this.engine.streamCall(execPrompt, this.history, (t) => this.print(t, "exec"));

            // 3. CRITIC
            this.print("\n\n[CRITIQUE]\n", "critic");
            const criticPrompt = `Result: ${result}\nä¸Šè¨˜ã‚’å³æ ¼ã«è©•ä¾¡ã›ã‚ˆã€‚0ã€œ100ç‚¹ã§æ¡ç‚¹ã—ã€ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã›ã‚ˆã€‚\nSCORE: [æ•°å€¤]\nCOMMENT: [æ”¹å–„ç‚¹]`;
            const critique = await this.engine.streamCall(criticPrompt, this.history, (t) => this.print(t, "critic"));

            // ã‚¹ã‚³ã‚¢æŠ½å‡º
            const scoreMatch = critique.match(/SCORE:\s*(\d+)/);
            const score = scoreMatch ? parseInt(scoreMatch[1]) : 0;
            this.print(`\n[ITERATION SCORE: ${score}]\n`, "score");

            if (score > bestScore) {
                bestScore = score;
                bestResult = result;
            }

            if (score >= 90) {
                this.print("\nâœ… ç›®æ¨™ç²¾åº¦ã«åˆ°é”ã€‚æœ€é©è§£ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚\n", "status");
                break;
            }

            currentFeedback = critique;
            // å±¥æ­´ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è“„ç©
            this.history.push({ role: "user", parts: [{ text: `è©¦è¡Œ${i}çµæœ: ${result}` }] });
            this.history.push({ role: "model", parts: [{ text: `æ”¹å–„æ¡ˆã‚’ç†è§£ã€‚æ¬¡ã®è©¦è¡Œã§ä¿®æ­£ã—ã¾ã™ã€‚` }] });
        }

        this.print(`\n\nğŸ† FINAL STRATEGIC OUTPUT (Score: ${bestScore})\n\n${bestResult}\n`, "final");
    }

    stop() {
        this.engine.controller?.abort();
        this.print("\n\n[STOPPED] ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚Šåœæ­¢ã•ã‚Œã¾ã—ãŸã€‚", "error");
    }
}

// UI Linking
const runBtn = document.getElementById("runBtn");
const stopBtn = document.getElementById("stopBtn");
const outputEl = document.getElementById("output");
let currentOrchestrator = null;

runBtn.addEventListener("click", async () => {
    const key = document.getElementById("apiKey").value.trim();
    const task = document.getElementById("prompt").value.trim();

    if (!key || !task) return alert("APIã‚­ãƒ¼ã¨ã‚¿ã‚¹ã‚¯ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");

    runBtn.disabled = true;
    stopBtn.style.display = "inline";
    outputEl.textContent = "Agent Initializing...";

    currentOrchestrator = new Orchestrator(key, outputEl);

    try {
        await currentOrchestrator.start(task);
    } catch (e) {
        const errorSpan = document.createElement("span");
        errorSpan.className = "error";
        errorSpan.textContent = `\n\n${e.message}`;
        outputEl.appendChild(errorSpan);
    } finally {
        runBtn.disabled = false;
        stopBtn.style.display = "none";
    }
});

stopBtn.addEventListener("click", () => currentOrchestrator?.stop());

</script>
</body>
</html>
